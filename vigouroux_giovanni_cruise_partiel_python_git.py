# -*- coding: utf-8 -*-
"""VIGOUROUX_Giovanni_Cruise_Partiel_Python-Git.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qMqwgKv7bWnE1SA2HpubrjZwS1YYwMF2

## Fonction polynome
"""

# x3 - 1.5x2 - 6x + 5
poly = [1, -1.5, -6, 5]
x = 5
n = len(poly)
  
# Servira a stocker et afficher le resultat du calcul
result = 0
  
# Boucle pour parcourir la liste
for i in range(n):
  
    # Declaring the variable Sum
    Sum = poly[i]
  
    # On parcourt la boucle pour multiplier x (n-i-1)
    # par le coefficient actuel 
    for j in range(n - i - 1):
        Sum = Sum * x
  
    # On ajoute la somme au resultat
    result = result + Sum
  

print(result)

"""## Fonction factorielle"""

from numpy.lib.type_check import iscomplex
def facto(x):
    """Fonction recursive pour trouver le facto d'un entier"""

    if x == 1 or x == 0:
        return 1

    if type(x) == str:
        print('Veuiller entrer un entier')

    if iscomplex(x):
        print('Cette fonction ne prend pas les nombres complexes. Veuillez entrer un entier')
        return

    if x < 0:
        print('Veuiller entrer un entier positif')
    
    if len(str(x)) > 3 or x > 966:   #un trop grand nombre dans le cas de ma fonction, est lié au nombre total d'appel récursif possible à la suite (966)
        print('Veuiller entrer un chiffre plus petit')
        return
    
    if len(str(x)) < 0:
        print('Veuiller entrer un chiffre plus petit')
        return
    
    else:
        # appel recursif de la fonction
        return (x * facto(x-1))


num = 967           # valeur de l'entier dont on veut le facto
facto(num)

"""# Suite de Fibo"""

def fibonacci(n):
    """Fonction recursive pour la suite de Fibo"""

    if(n <= 1):
        return n
    else:
        return (fibonacci(n-1) + fibonacci(n-2))

n = 6
for i in range(n):
    print(fibonacci(i))

"""# Formule de Black-Scholes-Merton"""

import numpy as np
from scipy.stats import norm
montant_sous_jacent = 100
prix_exercice = 1.1
sigma = 0.2
mu = 0.06
r = 0.015
S0 = 1
t = 1

def fun_d1(sigma,k,t,r,x):
    return (np.log(x/k) + (r+sigma**2/2)*t)/(sigma*np.sqrt(t))

def fun_d2(sigma,k,t,r,x):
    return fun_d1(sigma,k,t,r,x) - sigma*np.sqrt(t)

def call_value(montant_sous_jacent, sigma,k,t,r,x):
    d1 = fun_d1(sigma,k,t,r,x)
    d2 = fun_d2(sigma,k,t,r,x)
    temp = norm.cdf(d1)*x-norm.cdf(d2)*k*np.exp(-r*t)
    return montant_sous_jacent * temp
   
C0 = call_value(montant_sous_jacent, sigma,prix_exercice,t,r,S0)
print(C0)